name: Deploy Line Bot to GCE (clean)

on:
  push:
    branches: [ main ]                  # 需要時可改
    paths:
      - "**/*.py"
      - "requirements.txt"
      - "uwsgi.ini"
      - "wsgi.py"
      - ".github/workflows/deploy-gce.yml"
  workflow_dispatch:
    inputs:
      do_pip_install:
        description: "部署後在 GCE 的 venv 內執行 pip install -r requirements.txt"
        type: boolean
        required: false
        default: false

concurrency:
  group: deploy-linebot
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      GCE_HOST: ${{ secrets.GCE_HOST }}         # 例：35.xx.xx.xx
      GCE_USER: ${{ secrets.GCE_USER }}         # 例：Amin（大小寫要一致）
      DEPLOY_PATH: $HOME/linebot                # 例：/home/Amin/linebot/
      SERVICE_NAME: ${{ secrets.SERVICE_NAME }} # 例：linebot

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare SSH (ed25519)
        run: |
          install -m 700 -d ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H "$GCE_HOST" >> ~/.ssh/known_hosts

      - name: Show CI public key (for GCE metadata)
        run: |
          ssh-keygen -y -f ~/.ssh/id_ed25519
    
      - name: Smoke test SSH
        run: |
          set -x
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes "${GCE_USER}@${GCE_HOST}"

      - name: Ensure remote deploy path exists
        run: |
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes \
            "${GCE_USER}@${GCE_HOST}" "mkdir -p '${DEPLOY_PATH}'"

      - name: Push LINE .env to VM via stdin
        shell: bash
        env:
          CHANNEL_ACCESS_TOKEN: ${{ secrets.LINE_CHANNEL_ACCESS_TOKEN }}
          CHANNEL_SECRET: ${{ secrets.LINE_CHANNEL_SECRET }}
        run: |
          set -euo pipefail
          umask 077
          printf 'CHANNEL_ACCESS_TOKEN=%s\nCHANNEL_SECRET=%s\n' \
            "$CHANNEL_ACCESS_TOKEN" "$CHANNEL_SECRET" > .env
      
          U=$(printf '%s' "${GCE_USER}" | tr -d '\r\n' | xargs)
          H=$(printf '%s' "${GCE_HOST}" | tr -d '\r\n' | xargs)
      
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes \
            -l "$U" -- "$H" '
              set -euo pipefail
              install -d -m 700 "$HOME/env"
              install -m 600 /dev/stdin "$HOME/env/.env"
            ' < .env
      
          rm -f .env

      - name: Verify .env on VM and show $HOME
        shell: bash
        run: |
          set -euo pipefail
          U=$(printf '%s' "${GCE_USER}" | tr -d '\r\n' | xargs)
          H=$(printf '%s' "${GCE_HOST}" | tr -d '\r\n' | xargs)
      
          # 透過 heredoc 把腳本丟到遠端執行（避免本機展開問題）
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes \
            -l "$U" -- "$H" "bash -s" <<'REMOTE'
          set -euo pipefail
      
          echo "REMOTE HOME=$HOME"
      
          FILE="$HOME/env/.env"
          if [ ! -f "$FILE" ]; then
            echo "ERROR: $FILE 不存在"; exit 1
          fi
      
          # 顯示基本屬性（不含內容）
          if command -v stat >/dev/null 2>&1; then
            stat -c "path=%n mode=%a owner=%U group=%G size=%s" "$FILE" || true
          else
            ls -l "$FILE" || true
          fi
      
          # 驗證必備鍵是否存在；只印出鍵名與長度，避免洩漏
          awk -F= '
            $1=="CHANNEL_ACCESS_TOKEN"{printf "CHANNEL_ACCESS_TOKEN length=%d\n", length($2); found++}
            $1=="CHANNEL_SECRET"{printf "CHANNEL_SECRET length=%d\n", length($2); found++}
            END{ if(found<2){ exit 2 } }
          ' "$FILE"
      
          # 額外給一個檔案指紋（不含內容），方便日後比對一致性
          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum "$FILE" | awk "{print \"sha256=\"\$1}"
          fi
          REMOTE

      - name: Prepare remote deploy path (mkdir/chown/chmod)
        shell: bash
        run: |
          set -euo pipefail
          # 清掉可能的 CR/LF
          GCE_USER_CLEAN=$(printf '%s' "${GCE_USER}" | tr -d '\r\n' | xargs)
          GCE_HOST_CLEAN=$(printf '%s' "${GCE_HOST}" | tr -d '\r\n' | xargs)
      
          # 首次連線先把 host key 加入 known_hosts，避免 StrictHostKeyChecking 卡住
          install -m 700 -d ~/.ssh
          ssh-keyscan -T 5 "$GCE_HOST_CLEAN" >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts || true
          chmod 600 ~/.ssh/id_ed25519 || true
      
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes \
            -l "$GCE_USER_CLEAN" -- "$GCE_HOST_CLEAN" \
            "set -euo pipefail; \
             sudo mkdir -p '${DEPLOY_PATH}' && \
             sudo chown -R \$USER:\$USER '${DEPLOY_PATH}' && \
             sudo chmod -R u+rwX '${DEPLOY_PATH}'"

      - name: Rsync code to GCE (repo root → DEPLOY_PATH)
        shell: bash
        run: |
          set -euo pipefail
          GCE_USER_CLEAN=$(printf '%s' "${GCE_USER}" | tr -d '\r\n' | xargs)
          GCE_HOST_CLEAN=$(printf '%s' "${GCE_HOST}" | tr -d '\r\n' | xargs)
      
          rsync -vrtz --delete \
            --exclude '.git/' --exclude '.github/' --exclude '.gitignore' \
            --no-owner --no-group --omit-dir-times --no-perms \
            -e "ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes" \
            ./ "${GCE_USER_CLEAN}@${GCE_HOST_CLEAN}:${DEPLOY_PATH}/"

      - name: Install dependencies on VM (venv, optional)
        if: ${{ inputs.do_pip_install }}
        run: |
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes "${GCE_USER}@${GCE_HOST}" << EOF
          set -e
          cd "${DEPLOY_PATH}"
          if [ ! -d venv ]; then
            python3 -m venv venv
          fi
          . venv/bin/activate
          pip install --upgrade pip wheel
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          EOF

      - name: Restart service on VM (wait until active + logs if fail)
        shell: bash
        run: |
          set -euo pipefail
          U=$(printf '%s' "${GCE_USER}" | tr -d '\r\n' | xargs)
          H=$(printf '%s' "${GCE_HOST}" | tr -d '\r\n' | xargs)
          SVC=$(printf '%s' "${SERVICE_NAME}" | tr -d '\r\n' | xargs)
      
          # 將遠端腳本用 Heredoc 傳給 bash -s --，SERVICE_NAME 當 $1 傳入
          ssh -o IdentitiesOnly=yes -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=yes \
            -l "$U" -- "$H" "bash -s -- $(printf %q "$SVC")" <<'REMOTE'
          set -euo pipefail
          SERVICE_NAME="$1"
      
          # 無互動 sudo（避免需要 TTY 輸入密碼）
          sudo -n systemctl daemon-reload || true
          sudo -n systemctl restart "$SERVICE_NAME"
      
          # 等待 active / failed，最長 300 秒
          for i in {1..300}; do
            state=$(sudo -n systemctl is-active "$SERVICE_NAME" || true)
            echo "state=$state"
            if [ "$state" = "active" ]; then
              sudo -n systemctl --no-pager -l status "$SERVICE_NAME" || true
              exit 0
            fi
            if [ "$state" = "failed" ]; then
              sudo -n systemctl --no-pager -l status "$SERVICE_NAME" || true
              sudo -n journalctl -u "$SERVICE_NAME" -n 200 --no-pager || true
              exit 1
            fi
            sleep 1
          done
      
          echo 'Timed out waiting for service to become active'
          sudo -n systemctl --no-pager -l status "$SERVICE_NAME" || true
          sudo -n journalctl -u "$SERVICE_NAME" -n 200 --no-pager || true
          exit 1
          REMOTE
